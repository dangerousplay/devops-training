### **5 - Managing Dynamic Secrets and Tokens with Vault Leases**

**üéØ Lesson Objective:**

By completing these exercises, you will be able to:

1.  **Inspect the lease** metadata of a token generated by an auth method.
2.  **Renew a lease** to extend the validity of a token.
3.  **Manually revoke** a specific lease to invalidate a token immediately.
4.  **Demonstrate** how revoking a parent token automatically revokes all secrets and tokens it created.
5.  **Perform a prefix-based revocation**, a powerful tool for operators.

-----

### **Prerequisites**

- Read [Vault Lease, renew, and revoke](https://developer.hashicorp.com/vault/docs/concepts/lease)

### **Setup: Preparing Your Lab Environment**

1.  Start your Vault dev server:
    ```shell
    vault server -dev
    ```
2.  Copy the **Root Token** from the output.
3.  In a **new terminal window**, set up your environment variables:
    ```shell
    export VAULT_ADDR='http://127.0.0.1:8200'
    export VAULT_TOKEN='<PASTE_THE_ROOT_TOKEN_HERE>'
    ```
4.  Enable the `userpass` auth method for our exercises:
    ```shell
    vault auth enable userpass
    ```
5.  Create a user and policy for testing:
    ```shell
    vault policy write default-policy -<<EOF
    path "secret/data/*" { capabilities = ["read"] }
    EOF
    vault write auth/userpass/users/test-user password="password" policies="default-policy"
    ```

-----

### **Lab Exercises**

#### **Exercise 1: Observing a Lease in Action**

Every token generated from an auth method comes with a lease. Let's see it.

1.  **Command:** Log in as our `test-user`. The output itself is a lease.
    ```shell
    vault login -method=userpass username=test-user password=password
    ```
2.  **Observation:** Look at the output. You'll see fields like `token_duration` and `token_renewable`. This is the lease metadata. The `accessor` value is the **Lease ID** for this token. Copy the `token` and `accessor` values.
3.  **Command:** Let's look up the token to see its remaining time-to-live (TTL).
    ```shell
    vault token lookup <PASTE_THE_TOKEN_HERE>
    ```
4.  **Observation:** Note the `ttl` field. This is a countdown timer, in seconds.

> **‚ùì Question:** What is the initial `ttl` of the token you just received? According to the documentation, what does this value represent for an application using this token?

-----

#### **Exercise 2: Renewing a Lease to Extend It**

An application needs to periodically "check in" with Vault to renew its lease and keep its token valid.

1.  **Command:** Let's create a new token specifically for this test with a very short TTL to make the effect obvious. We'll use the root token for this.
    ```shell
    vault token create -policy="default-policy" -ttl="120s" 
    ```
2.  **Action:** Copy the new token's `token` and `token_accessor` values.
3.  **Command:** Immediately look up the token to see its initial TTL.
    ```shell
    vault token lookup <PASTE_THE_120s_TOKEN>
    ```
4.  **Command:** Now, wait for about 30 seconds and run the lookup command again.
    ```shell
    sleep 30
    vault token lookup <PASTE_THE_120s_TOKEN>
    ```
5.  **Observation:** You will see that the `ttl` value has decreased. The clock is ticking\!
6.  **Command:** Now, let's renew the lease for this token before it expires. `vault token renew` is the command for managing a token's lease.
    ```shell
    vault token renew <PASTE_THE_120s_TOKEN>
    ```
7.  **Observation:** The TTL has been reset to its original value of 120 seconds. We've successfully extended its life.

> **‚ùì Question:** The documentation says a client can request a renewal `increment`. If you wanted to renew this token but only have it be valid for 60 more seconds, how would you modify the command? (Hint: check `vault token renew -h`).

-----

#### **Exercise 3: The Ripple Effect - Parent Token Revocation**

The documentation states: "When a token is revoked, Vault will revoke all leases that were created using that token." This is a powerful "cascade" effect. Let's prove it.

1.  **Command:** First, log in as our `test-user` to get a "parent" token.
    ```shell
    vault login -method=userpass username=test-user password=password
    ```
2.  **Action:** Copy the new token. Now, **use this new token** to authenticate your terminal session.
    ```shell
    export VAULT_TOKEN=<PASTE_THE_TEST-USER_TOKEN_HERE>
    ```
3.  **Command:** As the `test-user`, create a "child" token.
    ```shell
    vault token create -policy="default-policy" -ttl="10m"
    ```
4.  **Action:** Save the `token` and `accessor` of this new **child token**. Verify it's valid with `vault token lookup <child_token>`.
5.  **Action:** Now, switch back to your **root token** to act as the administrator.
    ```shell
    export VAULT_TOKEN=<PASTE_THE_ROOT_TOKEN_HERE>
    ```
6.  **Command:** Revoke the **parent token** (the one from `test-user`).
    ```shell
    vault token revoke <PASTE_THE_TEST-USER_TOKEN_HERE>
    ```
7.  **Command:** Now, immediately try to look up the **child token**.
    ```shell
    vault token lookup <PASTE_THE_CHILD_TOKEN_HERE>
    ```
8.  **Observation:** The command will fail\! The child token was automatically invalidated the moment its parent was revoked.

> **‚ùì Question:** Imagine a scenario where a developer leaves the company. How does this lease revocation hierarchy allow a security team to instantly and completely cut off all access that originated from that developer's credentials?

-----

#### **Exercise 4: Prefix-Based Revocation for Mass Invalidation**

This is a powerful operator tool for emergencies. It allows revoking entire trees of secrets and tokens.

1.  **Action:** Make sure you are using your **root token**.
2.  **Command:** To simulate two different systems, let's enable another `userpass` backend at a different path.
    ```shell
    vault auth enable -path=staging-users userpass
    vault write auth/staging-users/users/stage-user password="password" policies="default-policy"
    ```
3.  **Action:** Now, generate two active leases by logging into both systems.
    ```shell
    # Login to the first system
    vault login -method=userpass username=test-user password=password > /dev/null

    # Login to the second system
    vault login -path=staging-users -method=userpass username=stage-user password=password > /dev/null
    ```
4.  **Command:** Now, imagine there's a security incident in your original `userpass` system. You need to revoke every single token issued by it, without affecting the `staging-users` system. The lease ID prefix for tokens is `auth/<mount_path>/...`.
    ```shell
    vault lease revoke -prefix auth/userpass/
    ```
5.  **Action:** Now, try to log in again as `test-user`. It will work because you are creating a *new* lease. But any token created *before* the revocation is now invalid.

> **‚ùì Question:** In the main Cookiebot project, our GitLab jobs will authenticate via the `jwt` method at `auth/jwt/...`. If you suspected a runner was compromised, what single command could you use to invalidate every single token ever issued to your GitLab jobs?