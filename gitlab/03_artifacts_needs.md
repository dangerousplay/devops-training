### **Pipeline Flow with `needs` and `artifacts`**

**ðŸŽ¯ Lesson Objective:**

By the end of this lesson, you will be able to:

1.  **Run jobs in parallel** across different stages using the `needs` keyword.
2.  **Clearly explain the purpose of `artifacts`** and how they differ from `cache`.
3.  **Configure a job to produce an artifact** (the `cookiebot.jar`).
4.  **Download and inspect** the artifacts directly from the GitLab UI.

-----

### **1. Optimizing for Speed: Breaking the Stage Barrier with `needs`**

**The Concept:** By default, GitLab CI waits for every single job in a stage to finish before starting any job in the next stage. This can create unnecessary bottlenecks.

Imagine you have a `test` stage with three jobs:

* `unit-tests` (takes 1 minute)
* `integration-tests` (takes 5 minutes)
* `security-scan` (takes 8 minutes)

A `package` job in the next stage has to wait the full 8 minutes for the entire `test` stage to complete, even if it only really depends on the 1-minute `unit-tests`.

The **`needs`** keyword solves this. 
It lets you create a Directed Acyclic Graph (DAG), allowing a job to start as soon as the *specific jobs* it depends on are finished, regardless of what stage they are in.

**Practical Application (Cookiebot):**

Let's see how this changes our pipeline structure.

**Example 1: The "Before" Pipeline (Slow and Rigid)**

```yaml
stages:
  - test
  - build

unit-tests:
  stage: test
  script:
    - mvn test

security-scan:
  stage: test
  script:
    - echo "Running long security scan..."
    - sleep 300 # Simulates a 5-minute scan

build_cookiebot:
  stage: build # Must wait for BOTH test jobs to finish (5+ minutes)
  script:
    - mvn package
```

Now, let's add the `needs` keyword to tell the `build_cookiebot` job it only needs the `unit-tests` to be complete.

**Example 2: The "After" Pipeline (Fast and Efficient with `needs`)**

```yaml
stages:
  - test
  - build

unit-tests:
  stage: test
  script:
    - mvn test

security-scan:
  stage: test
  script:
    - echo "Running long security scan..."
    - sleep 300

build_cookiebot:
  stage: build
  needs: [unit-tests] # This is the magic line!
  script:
    - mvn package
```

**The Result:** The `build_cookiebot` job will now start as soon as `unit-tests` finishes (after ~1 minute), running in parallel with the long `security-scan` job. 
We just saved several minutes of waiting time.

**Your Exercise:**

* In your Cookiebot pipeline, create two jobs in the `test` stage as shown in the example above.
* Add the `needs: [unit-tests]` keyword to your `build` job.
* Run the pipeline and observe the "DAG" or "Needs" view to see how the jobs run in parallel.

> ðŸ“š **Documentation:** [GitLab CI/CD `needs` keyword](https://docs.gitlab.com/ci/yaml/#needs)

-----

### **2. Artifacts: The Handoff Between Jobs**

**The Concept:** We've discussed this before, but it's critical to master. 
If `cache` is the pantry that speeds up a job, **`artifacts` are the finished product** that a job creates and hands off to the rest of the world.

An artifact is any file or directory generated by a job that you want to:

1.  Pass to a job in a later stage.
2.  Download from the GitLab UI to inspect yourself.

**Practical Application (Saving the Cookiebot Executable):**

Your `build` job compiles the code and produces a `cookiebot.jar` file. 
This is the most important result of the entire CI process. 
We need to declare it as an artifact so our future `deploy` job can use it.

**Example: Defining an Artifact**

```yaml
build_cookiebot:
  stage: build
  script:
    - mvn package
  artifacts:
    name: "cookiebot-build-${CI_COMMIT_SHORT_SHA}" # A descriptive name for the artifact zip
    paths:
      - target/cookiebot-*.jar # The path to the file(s) you want to save
    expire_in: 1 week # How long to keep the artifact
```

- **`name`**: Gives the downloadable zip file a unique name, often including the commit ID.
- **`paths`**: The most important part. It tells GitLab which file(s) or folder(s) to save. 
You can use wildcards (`*`).
- **`expire_in`**: It's good practice to set an expiration date to save storage space.

**Your Exercise: Downloading the Artifact**
1.  Add the `artifacts` section to your `build_cookiebot` job.
2.  Run the pipeline and wait for it to complete successfully.
3.  Follow these steps to download your `cookiebot.jar`:
    * Go to your project in GitLab.
    * From the left sidebar, navigate to **CI/CD > Pipelines**.
    * Click on the ID of the latest successful pipeline.
    * On the right side of the screen, you will see a section called **Job artifacts**.
    * Click the **Download** button. This will save a `.zip` file to your computer containing the `.jar` file.

Being able to produce and inspect artifacts is a fundamental troubleshooting skill. 
If a deployment fails, your first question should be: "Did the build job produce the correct artifact?" Now you know how to check.

> ðŸ“š **Documentation:** [GitLab CI/CD `artifacts` keyword](https://docs.gitlab.com/ci/jobs/job_artifacts/)